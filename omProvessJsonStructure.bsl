// LICENSE Attribution 4.0 International (CC BY 4.0).
// https://creativecommons.org/licenses/by/4.0/legalcode
// 

Функция ВернутьJSONСтрокой(ИспользоватьРасширеннуюСтруктуруПроверки  = Ложь) Экспорт
	Возврат ?(НЕ ИспользоватьРасширеннуюСтруктуруПроверки,
	// Стандартная структура
	"{
	|""kkm_uuid"": ""71a08f7c-1bb6-11e8-8351-f01fafd7431a"",
	|""staff_uuid"": ""e4c5a037-92f6-11e7-8416-005056b34cfa"",
	|""customer_uuid"": ""ac63a2fb-42dc-11e3-9038-00221965065c"",
	|""receipt"": {
	|""uuid"": """",
	|""operation"": ""presale"",
	|""add_bonus"": true,
	|""coupons"": [
	|],
	|""promokods"": [
	|],
	|""bonus"": ""true"",
	|""products"": [
	|{
	|""id"": 1,
	|""barcode"": """"
	|}
	|]
	|}
	|}",
    // РасширеннаяСтруктура
	"{
	|""kkm_uuid"": ""71a08f7c-1bb6-11e8-8351-f01fafd7431a"",
	// remove staff_uuid""
	|""staff_uuid"": """",
	|""customer_uuid"": ""ac63a2fb-42dc-11e3-9038-00221965065c"",
	|""receipt"": {
	|""uuid"": """",
	|""operation"": ""presale"",
	|""add_bonus"": true,
	|""coupons"": [
	|],
	|""promokods"": [
	|],
	|""bonus"": ""true"",
	|""products"": [
	|{
	|""id"": 1,
	|""barcode"": ""a""
	|},
	// Add more products
	|{
	|""id"": 2,
	|""barcode"": """"
	|},
	|{
	|""id"": 3,
	|""barcode"": ""c""
	|},
	|{
	|""id"": 4,
	|""barcode"": """"
	|}
	|]
	|}
	|}");
	
КонецФункции

// Возвращает поля которые необходимо валидировать по ТЗ
//
Функция ВернутьМассивПолейВалидации()
	МассивПолейВалидации = Новый Массив();
	МассивПолейВалидации.Добавить("kkm_uuid");
	МассивПолейВалидации.Добавить("staff_uuid");
	МассивПолейВалидации.Добавить("customer_uuid");
	МассивПолейВалидации.Добавить("receipt");
	МассивПолейВалидации.Добавить("operation");
	МассивПолейВалидации.Добавить("bonus");
	МассивПолейВалидации.Добавить("products");
	МассивПолейВалидации.Добавить("id");
	МассивПолейВалидации.Добавить("barcode");
	Возврат МассивПолейВалидации;
КонецФункции

// ВАЛИДИРУЕТ 1 объект чека из ТЗ
//
// Параметры:
//  МассивПолейВалидации  - Массив - Массив строк полей, проверяет наличие поля
//                 и его заполнение
//  СтрокаJSON  - Строка - Строка в формате JSON
//
Процедура ВалидироватьJSON(МассивПолейВалидации, СтрокаJSON) Экспорт
	Если СтрокаJSON = NULL
		ИЛИ ПустаяСтрока(СтрокаJSON) Тогда
		Возврат;
	КонецЕсли;
	
	Если МассивПолейВалидации = NULL
		ИЛИ (НЕ (ТипЗнч(МассивПолейВалидации) = Тип("Массив")))
	Тогда
		Возврат;
	КонецЕсли;
	
	Чтение = Новый ЧтениеJSON();
	Чтение.УстановитьСтроку(СтрокаJSON);
	СтруктураДанных = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();
	
	Если НЕ (ТипЗнч(СтруктураДанных) = Тип("Структура")) Тогда
		Возврат;
	КонецЕсли;
	ЕстьОшибки = Ложь;
	МассивСообщенийОшибки = Новый Массив();
	СтрокаХК = "";
	ЕстьОшибки = РекурсивноОбработатьПоСтруктуре(СтруктураДанных, МассивПолейВалидации, МассивСообщенийОшибки, СтрокаХК);
	Если ЕстьОшибки И МассивСообщенийОшибки.Количество() > 0 Тогда 
	    Сообщение = Новый СообщениеПользователю();
		Сообщение.УстановитьДанные(СтруктураДанных);
		Сообщение.Текст = "Обнаружены ошибки заполнения обязательных полей в валидируемой струкутре "
		    + Символы.ПС
		    + СтрСоединить(МассивСообщенийОшибки, Символы.ПС);
		Сообщение.Сообщить();
	КонецЕсли;
КонецПроцедуры                                      

// Проверяет значение структуры на допустимое
//
Функция ВернутьПроверкуЗначенияСтруктуры(ЗначениеСтруктуры)
    Возврат (СтрСтруктуры.Значение = Неопределено
		ИЛИ (СтрСтруктуры.Значение = NULL)
		ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Строка") И ПустаяСтрока(СтрСтруктуры.Значение))
		ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Число") И НольКакПустое И СтрСтруктуры.Значение = 0) 
		ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Дата") И СтрСтруктуры.Значение = '00010101'));
КонецФункции

// Рекурсивно обрабатывает структуру чека
//
// Параметры:
//  СтруктураДанных  - Структура - Преобразованный JSON в струкутру
//  МассивПроверяемыхПолей  - Массив - Массив строк с проверяемыми полями
//		{"kkm_uuid", "uuid", ... }
//	МассивСообщенийОшибки  - Массив - Массив массив строк в который будут 
//		возаращены пути по структуре которые не были корректно валидированы
//	ХК - Строка - Хлебные крошки Ключ корня от текущей структуры
//	ОграничениеРекурсии - Число - Если больше 1 рекурсия будет ограничена (количеством в параметре -1) 
//		и в случае ограниченя возвратит истина в ошибках
//	НольКакПустое - Булево - Если валидируемое числовое поле = 0 при значении истина валидация не будет пройдена
//		при значении Ложь будет пройдена, по умолчанию <Ложь>
//
Функция РекурсивноОбработатьПоСтруктуре(СтруктураДанных, МассивПроверяемыхПолей, МассивСообщенийОшибки, ХК = "", ОграничениеРекурсии = 0, НольКакПустое = Ложь)
	ЕстьОшибки = Ложь;
	
	Если ОграничениеРекурсии > 1 Тогда
	    ОграничениеРекурсии = ОграничениеРекурсии - 1;
	Иначе
	    Если ОграничениеРекурсии = 1 Тогда
		МассивСообщенийОшибки.Добавить(ХК  + "." + СтрСтруктуры.Ключ + " Достигнуто ограничение рекурсии");
		Возврат Истина;
	    КонецЕсли;
	КонецЕсли;
	
	Для Каждого СтрСтруктуры Из СтруктураДанных Цикл
		Если ТипЗнч(СтрСтруктуры.Значение) = Тип("Структура") Тогда
			ЕстьОшибки = РекурсивноОбработатьПоСтруктуре(СтрСтруктуры.Значение, МассивПроверяемыхПолей, МассивСообщенийОшибки, ХК + "." + СтрСтруктуры.Ключ);
		ИначеЕсли ТипЗнч(СтрСтруктуры.Значение) = Тип("Массив") 
			И  СтрСтруктуры.Значение.Количество() > 0 Тогда
				мИндекс = 0;
				Для Каждого СтрМ Из СтрСтруктуры.Значение Цикл
					ЕстьОшибки = РекурсивноОбработатьПоСтруктуре(СтрМ, МассивПроверяемыхПолей, МассивСообщенийОшибки,
					    ХК + "." + СтрСтруктуры.Ключ + "[" + Строка(мИндекс) + "]");
					мИндекс = мИндекс + 1;
				КонецЦикла;
		Иначе
			Если НЕ МассивПроверяемыхПолей.Найти(СтрСтруктуры.Ключ) = Неопределено Тогда
				Если ВернутьПроверкуЗначенияСтруктуры(СтрСтруктуры.Значение) Тогда
					МассивСообщенийОшибки.Добавить(ХК  + "." + СтрСтруктуры.Ключ);
					ЕстьОшибки = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ЕстьОшибки;
КонецФункции

// ТестКода
//
Процедура Тест() Экспорт    
	МассивПолейВалидации = ВернутьМассивПолейВалидации();
	ВалидироватьJSON(МассивПолейВалидации, ВернутьJSONСтрокой());
КонецПроцедуры 
