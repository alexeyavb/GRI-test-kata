// LICENSE Attribution 4.0 International (CC BY 4.0).
// https://creativecommons.org/licenses/by/4.0/legalcode
// 
// Copyright (c) Alex V. Barnukoff 2025/02/06

Функция ВернутьJSONСтрокой(ИспользоватьРасширеннуюСтруктуруПроверки  = ЛОЖЬ) Экспорт		
	Возврат ?(НЕ ИспользоватьРасширеннуюСтруктуруПроверки,
	// Стандартная структура
	"{
	|""kkm_uuid"": ""71a08f7c-1bb6-11e8-8351-f01fafd7431a"",
	|""staff_uuid"": ""e4c5a037-92f6-11e7-8416-005056b34cfa"",
	|""customer_uuid"": ""ac63a2fb-42dc-11e3-9038-00221965065c"",
	|""receipt"": {
	|""uuid"": """",
	|""operation"": ""presale"",
	|""add_bonus"": true,
	|""coupons"": [
	|],
	|""promokods"": [
	|],
	|""bonus"": ""true"",
	|""products"": [
	|{
	|""id"": 1,
	|""barcode"": """"
	|}
	|]
	|}
	|}",		
    // РасширеннаяСтруктура
	"{
	|""kkm_uuid"": ""71a08f7c-1bb6-11e8-8351-f01fafd7431a"",
	// remove staff_uuid""
	|""staff_uuid"": """",
	|""customer_uuid"": ""ac63a2fb-42dc-11e3-9038-00221965065c"",
	|""receipt"": {
	|""uuid"": """",
	|""operation"": ""presale"",
	|""add_bonus"": true,
	|""coupons"": [
	|],
	|""promokods"": [
	|],
	|""bonus"": ""true"",
	|""products"": [
	|{
	|""id"": 1,
	|""barcode"": ""a""
	|},
	// Add more products
	|{
	|""id"": 2,
	|""barcode"": """"
	|},
	|{
	|""id"": 3,
	|""barcode"": ""c""
	|},
	|{
	|""id"": 4,
	|""barcode"": """"
	|}		
	|]
	|}
	|}");
	
КонецФункции

// Возвращает поля которые необходимо валидировать по ТЗ
//
Функция ВернутьМассивПолейВалидации()
	МассивПолейВалидации = Новый Массив();
	МассивПолейВалидации.Добавить("kkm_uuid");
	МассивПолейВалидации.Добавить("staff_uuid");
	МассивПолейВалидации.Добавить("customer_uuid");
	МассивПолейВалидации.Добавить("receipt");
	МассивПолейВалидации.Добавить("operation");
	МассивПолейВалидации.Добавить("bonus");
	МассивПолейВалидации.Добавить("products");
	МассивПолейВалидации.Добавить("id");
	МассивПолейВалидации.Добавить("barcode");
	Возврат МассивПолейВалидации;
КонецФункции

// ВАЛИДИРУЕТ 1 объект чека из ТЗ
//
// Параметры:
//  ПоляВалидации  - Массив - Массив строк полей, проверяет наличие поля
//                 и его заполнение
//  СтрокаJSON  - Строка - Строка в формате JSON
//
Процедура ВалидироватьJSON(МассивПолейВалидации, СтрокаJSON) Экспорт
	
	Если СтрокаJSON = NULL
		ИЛИ ПустаяСтрока(СтрокаJSON) Тогда
		Возврат;
	КонецЕсли;
	
	Если МассивПолейВалидации = NULL
		ИЛИ (НЕ (ТипЗнч(МассивПолейВалидации) = Тип("Массив")))
	Тогда
		Возврат;
	КонецЕсли;
	
	Чтение = Новый ЧтениеJSON();
	Чтение.УстановитьСтроку(СтрокаJSON);
	СтруктураДанных = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();
	
	Если НЕ (ТипЗнч(СтруктураДанных) = Тип("Структура")) Тогда
		Возврат;
	КонецЕсли;
	ЕстьОшибки = ЛОЖЬ;
	МассивСообщенийОшибки = Новый Массив();             
	СтрокаХК = "";
	РекурсивноОбработатьПоСтруктуре(СтруктураДанных, МассивПолейВалидации, МассивСообщенийОшибки, СтрокаХК);
	Если МассивСообщенийОшибки.Количество() > 0 Тогда 
	    Сообщение = Новый СообщениеПользователю();
		Сообщение.УстановитьДанные(СтруктураДанных);
		Сообщение.Текст = "Обнаружены ошибки заполнения обязательных полей в валидируемой струкутре " + Символы.ПС
			+ СтрСоединить(МассивСообщенийОшибки, Символы.ПС
			);
		Сообщение.Сообщить();
	КонецЕсли;
КонецПроцедуры                                      

// Рекурсивно обрабатывает структуру чека
//
// Параметры:
//  СтруктураДанных  - Структура - Преобразованный JSON в струкутру
//  МассивПроверяемыхПолей  - Массив - Массив строк с проверяемыми полями
//		{"kkm_uuid", "uuid", ... }
//	МассивСообщенийОшибки  - Массив - Массив массив строк в который будут 
//		возаращены пути по структуре которые не были корректно валидированы
//	ХК - Строка - Хлебные крошки Ключ корня от текущей структуры
//  НольКакПустое - Булево - Если валидируемое числовое поле = 0 при значении истина валидация не будет пройдена
//		при значении ложь будет пройдена, по умолчанию <Ложь>
//
Функция РекурсивноОбработатьПоСтруктуре(СтруктураДанных, МассивПроверяемыхПолей, МассивСообщенийОшибки, ХК = "", НольКакПустое = ЛОЖЬ)
	ЕстьОшибки = ЛОЖЬ;
	Для Каждого СтрСтруктуры ИЗ СтруктураДанных Цикл
		Если ТипЗнч(СтрСтруктуры.Значение) = Тип("Структура") Тогда
			БылиОш = РекурсивноОбработатьПоСтруктуре(СтрСтруктуры.Значение, МассивПроверяемыхПолей, МассивСообщенийОшибки, ХК + "." + СтрСтруктуры.Ключ);
		ИначеЕсли ТипЗнч(СтрСтруктуры.Значение) = Тип("Массив") 
			И  СтрСтруктуры.Значение.Количество() > 0 Тогда
				мИндекс = 0;
				Для Каждого СтрМ ИЗ СтрСтруктуры.Значение Цикл
					БылиОш = РекурсивноОбработатьПоСтруктуре(СтрМ, МассивПроверяемыхПолей, МассивСообщенийОшибки,  ХК + "." + СтрСтруктуры.Ключ + "[" + Строка(мИндекс) + "]");
					мИндекс = мИндекс+1;
				КонецЦикла;
		Иначе
			Если НЕ МассивПроверяемыхПолей.Найти(СтрСтруктуры.Ключ) = Неопределено Тогда
				Если СтрСтруктуры.Значение = Неопределено
					ИЛИ СтрСтруктуры.Значение = NULL
					ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Строка") И ПустаяСтрока(СтрСтруктуры.Значение))
					ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Число") И СтрСтруктуры.Значение = 0 И НольКакПустое) 
					ИЛИ (ТипЗнч(СтрСтруктуры.Значение) = Тип("Дата") И СтрСтруктуры.Значение = '00010101')  
				Тогда
					МассивСообщенийОшибки.Добавить(ХК  + "." + СтрСтруктуры.Ключ);
					ЕстьОшибки = Истина;
				КонецЕсли;					
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат ЕстьОшибки;
КонецФункции

// ТестКода
//
Процедура Тест() Экспорт    
	МассивПолейВалидации = ВернутьМассивПолейВалидации();
	ВалидироватьJSON(МассивПолейВалидации, ВернутьJSONСтрокой());
КонецПроцедуры 


